"""
Prediction Module

Orchestrates the complete prediction pipeline: feature extraction â†’ preprocessing â†’ prediction.
Follows SOLID principles with clear separation of concerns.

Author: MLOps Team 24
Date: November 2024
"""

import logging
from pathlib import Path
from typing import Dict, Tuple, Optional
import pandas as pd
import numpy as np

from utils.audio_feature_extractor import AudioFeatureExtractor
from utils.model_loader import ModelLoader

logger = logging.getLogger(__name__)


class MusicEmotionPredictor:
    """
    End-to-end predictor for Turkish Music Emotion Recognition.
    
    Orchestrates:
    1. Feature extraction from audio
    2. Feature preprocessing
    3. Model prediction
    4. Result interpretation
    
    Single Responsibility: Coordinate prediction pipeline
    Open/Closed: Extensible without modifying existing code
    """
    
    def __init__(
        self,
        model_path: Path,
        emotion_classes: list = None,
        sr: int = 22050
    ):
        """
        Initialize emotion predictor.
        
        Args:
            model_path: Path to trained model
            emotion_classes: List of emotion class names
            sr: Audio sample rate
        """
        self.model_path = model_path
        self.emotion_classes = emotion_classes or ["Happy", "Sad", "Angry", "Relax"]
        self.sr = sr
        
        # Initialize components
        self.feature_extractor = AudioFeatureExtractor(sr=sr)
        self.model_loader = ModelLoader(model_path, apply_preprocessing=True)
        
        # Load model
        self._initialize_model()
        
    def _initialize_model(self) -> None:
        """Load and initialize the model."""
        try:
            self.model_loader.load_model()
            logger.info("âœ… Predictor initialized successfully")
        except Exception as e:
            logger.error(f"âŒ Failed to initialize predictor: {e}")
            raise
    
    def predict_from_audio(
        self,
        audio_path: Path,
        return_probabilities: bool = True
    ) -> Dict[str, any]:
        """
        Complete prediction pipeline from audio file.
        
        Args:
            audio_path: Path to audio file
            return_probabilities: Whether to return class probabilities
            
        Returns:
            Dictionary with prediction results:
            {
                'predicted_emotion': str,
                'confidence': float,
                'probabilities': dict (if return_probabilities=True),
                'features': dict,
                'all_scores': dict
            }
        """
        logger.info(f"ðŸŽµ Starting prediction for: {audio_path.name}")
        
        # Step 1: Extract features
        logger.info("  â†’ Extracting audio features...")
        features = self.feature_extractor.extract_features(audio_path)
        features_df = pd.DataFrame([features])
        
        # Step 2: Predict
        logger.info("  â†’ Making prediction...")
        prediction = self.model_loader.predict(features_df)
        predicted_emotion = self._decode_prediction(prediction[0])
        
        # Step 3: Get probabilities
        if return_probabilities:
            logger.info("  â†’ Computing probabilities...")
            probabilities = self.model_loader.predict_proba(features_df)[0]
            prob_dict = {
                emotion: float(prob)
                for emotion, prob in zip(self.emotion_classes, probabilities)
            }
            confidence = float(max(probabilities))
            
            # All scores for visualization
            all_scores = prob_dict
        else:
            prob_dict = None
            confidence = 1.0
            all_scores = {predicted_emotion: 1.0}
        
        logger.info(f"âœ… Prediction: {predicted_emotion} (confidence: {confidence:.2%})")
        
        return {
            'predicted_emotion': predicted_emotion,
            'confidence': confidence,
            'probabilities': prob_dict,
            'features': features,
            'all_scores': all_scores
        }
    
    def predict_batch(
        self,
        audio_paths: list,
        return_probabilities: bool = True
    ) -> pd.DataFrame:
        """
        Predict emotions for multiple audio files.
        
        Args:
            audio_paths: List of audio file paths
            return_probabilities: Whether to include probabilities
            
        Returns:
            DataFrame with predictions for all files
        """
        results = []
        
        for audio_path in audio_paths:
            try:
                result = self.predict_from_audio(audio_path, return_probabilities)
                result['audio_file'] = audio_path.name
                results.append(result)
            except Exception as e:
                logger.error(f"âŒ Failed to predict {audio_path.name}: {e}")
                continue
        
        return pd.DataFrame(results)
    
    def _decode_prediction(self, prediction: any) -> str:
        """
        Decode model prediction to emotion label.
        
        Args:
            prediction: Raw model prediction (int or str)
            
        Returns:
            Emotion label string
        """
        # If prediction is already a string label
        if isinstance(prediction, str):
            return prediction
        
        # If prediction is numeric index
        if isinstance(prediction, (int, np.integer)):
            if 0 <= prediction < len(self.emotion_classes):
                return self.emotion_classes[prediction]
        
        # Fallback
        logger.warning(f"âš ï¸  Unexpected prediction format: {prediction}")
        return str(prediction)
    
    def get_feature_importance(self) -> Optional[pd.DataFrame]:
        """
        Get feature importance from model.
        
        Returns:
            DataFrame with feature importance or None
        """
        feature_names = self.feature_extractor.feature_names
        return self.model_loader.get_feature_importance(feature_names)
    
    def explain_prediction(
        self,
        audio_path: Path,
        top_n: int = 10
    ) -> Dict[str, any]:
        """
        Explain prediction with feature contributions.
        
        Args:
            audio_path: Path to audio file
            top_n: Number of top features to show
            
        Returns:
            Dictionary with explanation
        """
        # Get prediction
        result = self.predict_from_audio(audio_path, return_probabilities=True)
        
        # Get feature importance
        importance_df = self.get_feature_importance()
        
        if importance_df is not None:
            top_features = importance_df.head(top_n)
        else:
            top_features = None
        
        explanation = {
            'prediction': result['predicted_emotion'],
            'confidence': result['confidence'],
            'probabilities': result['probabilities'],
            'top_features': top_features,
            'audio_file': audio_path.name
        }
        
        return explanation
    
    def validate_prediction(
        self,
        audio_path: Path,
        true_emotion: str
    ) -> Dict[str, any]:
        """
        Validate prediction against ground truth.
        
        Args:
            audio_path: Path to audio file
            true_emotion: Ground truth emotion label
            
        Returns:
            Dictionary with validation results
        """
        result = self.predict_from_audio(audio_path)
        
        predicted_emotion = result['predicted_emotion']
        is_correct = predicted_emotion == true_emotion
        
        validation = {
            'audio_file': audio_path.name,
            'true_emotion': true_emotion,
            'predicted_emotion': predicted_emotion,
            'is_correct': is_correct,
            'confidence': result['confidence'],
            'probabilities': result['probabilities']
        }
        
        logger.info(
            f"{'âœ…' if is_correct else 'âŒ'} "
            f"True: {true_emotion}, Predicted: {predicted_emotion}"
        )
        
        return validation


# ============================================================================
# CONVENIENCE FUNCTIONS
# ============================================================================

def quick_predict(model_path: Path, audio_path: Path) -> str:
    """
    Quick prediction function for single audio file.
    
    Args:
        model_path: Path to model
        audio_path: Path to audio
        
    Returns:
        Predicted emotion label
    """
    predictor = MusicEmotionPredictor(model_path)
    result = predictor.predict_from_audio(audio_path, return_probabilities=False)
    return result['predicted_emotion']


def predict_with_confidence(
    model_path: Path,
    audio_path: Path
) -> Tuple[str, float]:
    """
    Predict emotion with confidence score.
    
    Args:
        model_path: Path to model
        audio_path: Path to audio
        
    Returns:
        Tuple of (emotion, confidence)
    """
    predictor = MusicEmotionPredictor(model_path)
    result = predictor.predict_from_audio(audio_path, return_probabilities=True)
    return result['predicted_emotion'], result['confidence']
